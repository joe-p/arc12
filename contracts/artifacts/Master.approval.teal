#pragma version 10

// This TEAL was generated by TEALScript v0.86.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	err

// create()void
*abi_route_create:
	// execute create()void
	callsub create
	int 1
	return

// create(): void
create:
	proto 0 0
	retsub

// createVault(address,pay)uint64
*abi_route_createVault:
	// The ABI return prefix
	byte 0x151f7c75

	// mbrPayment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// receiver: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute createVault(address,pay)uint64
	callsub createVault
	itob
	concat
	log
	int 1
	return

// createVault(receiver: Address, mbrPayment: PayTxn): AppID
createVault:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// arc12.ts:142
	// assert(!this.vaultMap(receiver).exists)
	frame_dig -1 // receiver: Address
	box_len
	swap
	pop
	!
	assert

	// arc12.ts:143
	// assert(mbrPayment.receiver === globals.currentApplicationAddress)
	frame_dig -2 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// arc12.ts:144
	// assert(mbrPayment.sender === this.txn.sender)
	frame_dig -2 // mbrPayment: PayTxn
	gtxns Sender
	txn Sender
	==
	assert

	// arc12.ts:146
	// preCreateMBR = globals.currentApplicationAddress.minBalance
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	frame_bury 0 // preCreateMBR: uint64

	// arc12.ts:149
	// sendMethodCall<[Address, Address], void>({
	//       name: 'create',
	//       onCompletion: OnCompletion.NoOp,
	//       fee: 0,
	//       methodArgs: [receiver, this.txn.sender],
	//       clearStateProgram: this.app.clearStateProgram,
	//       approvalProgram: Vault.approvalProgram(),
	//       globalNumByteSlice: Vault.schema.global.numByteSlice,
	//       globalNumUint: Vault.schema.global.numUint,
	//     })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "create(address,address)void"
	itxn_field ApplicationArgs

	// arc12.ts:151
	// onCompletion: OnCompletion.NoOp
	int 0 // NoOp
	itxn_field OnCompletion

	// arc12.ts:152
	// fee: 0
	int 0
	itxn_field Fee

	// arc12.ts:153
	// methodArgs: [receiver, this.txn.sender]
	frame_dig -1 // receiver: Address
	itxn_field ApplicationArgs
	txn Sender
	itxn_field ApplicationArgs

	// arc12.ts:154
	// clearStateProgram: this.app.clearStateProgram
	txna Applications 0
	app_params_get AppClearStateProgram
	pop
	itxn_field ClearStateProgram

	// arc12.ts:155
	// approvalProgram: Vault.approvalProgram()
	byte b64 CiAEAQAgBCYEAAdjcmVhdG9yCHJlY2VpdmVyBm1hc3RlcjEYFIEGCzEZCI0MAigAAAAAAAAAAAJHAhoAAAAAAAAAAAJGAIoBACiL/ylkEkSxIrIQi/+yBzIKcwFIsggjsgExALIJszEWIgiMAIsAOBgrZBJEiwA5GgCABJtKZKUSRIsAOTIBNjIAEkSJNhoCSRUkEkQ2GgFJFSQSRIgAAiJDigIAKYv+ZyqL/2crMg1niTYaBEkVJBJENhoDFzYaAkkVJBJENhoBSRUkEkSIAAIiQ4oEAChJMQAqZBJEi/6AIMf8zbJY8NQYnCv4ttaO5pdQhkKwrQAfMfy5GMNUuoWaEkQyCnMBSIwAsSWyEIv/shSL/bIRI7ISi/+yFSOyAbOL/Ra8iwAyCnMBSAmMAbEishCL/rIHiwExAQmyCCOyAbOxIrIQMQCyBzEBsggjsgGzMgpzCUgjEkEABYv8iP7kiTEWIglJOBAiEkQ2GgEXiAACIkOKAgAoi/8WvUxIFESL/jgAMQASRIv+OAcyChJEMgpzAUiMAIv/FjEAv7ElshAyCrIUI7ISI7IBi/+yEbOL/jgIMgpzAUiLAAkSRIk2GgNJFSQSRDYaAkkVJBJENhoBF4gAAiJDigMAKIv/Fr1MSESL/Yv/Fr5EEkQxACpkEkQpZIv+EkQyCnMBSIwAi/8WvLElshAxALIUI7IBMgqL/3AASLISi/+yETEAshWzsSKyEIv9sgeLADIKcwFICbIII7IBszIKcwlIIxJBAAWL/oj9/4mIAAIiQ4oAADIKcwBMSBREMQAyCRJEiYAEipaYDjYaAI4B/iEAgASyEcSHgAQuZcsKgATVqkiWNhoAjgP+KP7Z/zcAADEbQf+3AA==
	itxn_field ApprovalProgram

	// arc12.ts:156
	// globalNumByteSlice: Vault.schema.global.numByteSlice
	int 2
	itxn_field GlobalNumByteSlice

	// arc12.ts:157
	// globalNumUint: Vault.schema.global.numUint
	int 1
	itxn_field GlobalNumUint

	// Submit inner transaction
	itxn_submit

	// arc12.ts:160
	// vault = this.itxn.createdApplicationID
	itxn CreatedApplicationID
	frame_bury 1 // vault: uint64

	// arc12.ts:163
	// sendPayment({
	//       receiver: vault.address,
	//       amount: globals.minBalance,
	//       fee: 0,
	//     })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// arc12.ts:164
	// receiver: vault.address
	frame_dig 1 // vault: uint64
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// arc12.ts:165
	// amount: globals.minBalance
	global MinBalance
	itxn_field Amount

	// arc12.ts:166
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// arc12.ts:169
	// this.vaultMap(receiver).value = vault
	frame_dig -1 // receiver: Address
	frame_dig 1 // vault: uint64
	itob
	box_put

	// arc12.ts:172
	// assert(mbrPayment.amount === (globals.currentApplicationAddress.minBalance - preCreateMBR) + globals.minBalance)
	frame_dig -2 // mbrPayment: PayTxn
	gtxns Amount
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	frame_dig 0 // preCreateMBR: uint64
	-
	global MinBalance
	+
	==
	assert

	// arc12.ts:174
	// return vault;
	frame_dig 1 // vault: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// verifyAxfer(address,axfer,uint64)void
*abi_route_verifyAxfer:
	// vault: uint64
	txna ApplicationArgs 2
	btoi

	// vaultAxfer: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==
	assert

	// receiver: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute verifyAxfer(address,axfer,uint64)void
	callsub verifyAxfer
	int 1
	return

// verifyAxfer(receiver: Address, vaultAxfer: AssetTransferTxn, vault: AppID): void
verifyAxfer:
	proto 3 0

	// arc12.ts:178
	// assert(this.vaultMap(receiver).exists)
	frame_dig -1 // receiver: Address
	box_len
	swap
	pop
	assert

	// arc12.ts:180
	// assert(this.vaultMap(receiver).value === vault)
	frame_dig -1 // receiver: Address
	box_get
	assert
	btoi
	frame_dig -3 // vault: AppID
	==
	assert

	// arc12.ts:181
	// assert(vaultAxfer.assetReceiver === vault.address)
	frame_dig -2 // vaultAxfer: AssetTransferTxn
	gtxns AssetReceiver
	frame_dig -3 // vault: AppID
	app_params_get AppAddress
	pop
	==
	assert

	// arc12.ts:182
	// assert(vaultAxfer.assetCloseTo === globals.zeroAddress)
	frame_dig -2 // vaultAxfer: AssetTransferTxn
	gtxns AssetCloseTo
	global ZeroAddress
	==
	assert
	retsub

// hasVault(address)uint64
*abi_route_hasVault:
	// The ABI return prefix
	byte 0x151f7c75

	// receiver: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute hasVault(address)uint64
	callsub hasVault
	itob
	concat
	log
	int 1
	return

// hasVault(receiver: Address): uint64
hasVault:
	proto 1 1

	// arc12.ts:187
	// return this.vaultMap(receiver).exists;
	frame_dig -1 // receiver: Address
	box_len
	swap
	pop
	retsub

// getVaultId(address)uint64
*abi_route_getVaultId:
	// The ABI return prefix
	byte 0x151f7c75

	// receiver: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute getVaultId(address)uint64
	callsub getVaultId
	itob
	concat
	log
	int 1
	return

// getVaultId(receiver: Address): AppID
getVaultId:
	proto 1 1

	// arc12.ts:191
	// return this.vaultMap(receiver).value;
	frame_dig -1 // receiver: Address
	box_get
	assert
	btoi
	retsub

// getVaultAddr(address)address
*abi_route_getVaultAddr:
	// The ABI return prefix
	byte 0x151f7c75

	// receiver: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute getVaultAddr(address)address
	callsub getVaultAddr
	concat
	log
	int 1
	return

// getVaultAddr(receiver: Address): Address
getVaultAddr:
	proto 1 1

	// arc12.ts:195
	// return this.vaultMap(receiver).value.address;
	app_params_get AppAddress
	pop
	retsub

// deleteVault(uint64,address)void
*abi_route_deleteVault:
	// vaultCreator: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// vault: uint64
	txna ApplicationArgs 1
	btoi

	// execute deleteVault(uint64,address)void
	callsub deleteVault
	int 1
	return

// deleteVault(vault: AppID, vaultCreator: Address): void
deleteVault:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// arc12.ts:201
	// assert(this.txn.fee === 0)
	txn Fee
	int 0
	==
	assert

	// arc12.ts:202
	// assert(vault === this.vaultMap(this.txn.sender).value)
	frame_dig -1 // vault: AppID
	txn Sender
	box_get
	assert
	btoi
	==
	assert

	// arc12.ts:204
	// assert(vault.globalState('creator') as Address === vaultCreator)
	frame_dig -1 // vault: AppID
	byte 0x63726561746f72 // "creator"
	app_global_get_ex
	assert
	frame_dig -2 // vaultCreator: Address
	==
	assert

	// arc12.ts:206
	// preDeleteMBR = globals.currentApplicationAddress.minBalance
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	frame_bury 0 // preDeleteMBR: uint64

	// arc12.ts:209
	// sendAppCall({
	//       applicationID: vault,
	//       onCompletion: OnCompletion.DeleteApplication,
	//       fee: 0,
	//     })
	itxn_begin
	int appl
	itxn_field TypeEnum

	// arc12.ts:210
	// applicationID: vault
	frame_dig -1 // vault: AppID
	itxn_field ApplicationID

	// arc12.ts:211
	// onCompletion: OnCompletion.DeleteApplication
	int 5 // DeleteApplication
	itxn_field OnCompletion

	// arc12.ts:212
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// arc12.ts:215
	// this.vaultMap(this.txn.sender).delete()
	txn Sender
	box_del

	// arc12.ts:218
	// sendPayment({
	//       receiver: vaultCreator,
	//       amount: preDeleteMBR - globals.currentApplicationAddress.minBalance,
	//       fee: 0,
	//     })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// arc12.ts:219
	// receiver: vaultCreator
	frame_dig -2 // vaultCreator: Address
	itxn_field Receiver

	// arc12.ts:220
	// amount: preDeleteMBR - globals.currentApplicationAddress.minBalance
	frame_dig 0 // preDeleteMBR: uint64
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	-
	itxn_field Amount

	// arc12.ts:221
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

*create_NoOp:
	txn NumAppArgs
	bz *abi_route_create
	err

*call_NoOp:
	method "createVault(address,pay)uint64"
	method "verifyAxfer(address,axfer,uint64)void"
	method "hasVault(address)uint64"
	method "getVaultId(address)uint64"
	method "getVaultAddr(address)address"
	method "deleteVault(uint64,address)void"
	txna ApplicationArgs 0
	match *abi_route_createVault *abi_route_verifyAxfer *abi_route_hasVault *abi_route_getVaultId *abi_route_getVaultAddr *abi_route_deleteVault
	err